一開始想說直接用窮舉的，但感覺一定會爆炸(2^N)  
注意數字有到非常大，要用long long  

### 網路上的解法 
看來也是使用窮舉，但是分成兩堆後有比較好一點(N*2^(N/2))，並且窮舉是使用位元運算     
分成兩堆後，找出Sa + Sb == T 的組合就行 => (Sa == T-Sb) + (Sa == T) + (Sb == T)

ex
```
6 0
-1 2 -3 4 -5 6
```
分成a、b兩堆 => `-1 2 -3` `4 -5 6`

### 如何窮舉 S
#### 利用位元運算
原理: 利用1出現的位置與個數去產生(j代表1出現的位置)  
```
i       i & (1<<j)     j
1         1            0
10        10           1
11        1 10         0 1
100       100          2
101       1 100        0 2
110       10 100       1 2
111       1 10 100     1 2 3 
```
### 一直TTL
使用map還不夠，要使用unordered_map  
但是unordered_map好像是C++11的==   
到底到時候能不能用C++11阿  
不然就要自己手刻hash table了  
